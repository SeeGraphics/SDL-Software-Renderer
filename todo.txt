
  2. Add attribute interpolation: compute barycentric weights in the filler. For a “rainbow” test, carry per-vertex color (float3) and interpolate. Store a
     z/depth buffer alongside color to prepare for 3D. Implement a tiny RasterTriangle struct with positions + attrs so the rasterizer doesn’t need to know
     about higher-level types.
  3. Go 3D: add v3/mat4 math, build model→view→projection→viewport pipeline, perspective divide, near/far clip, simple camera (pos + yaw/pitch or look-at).
     Render a single transformed triangle/quad with depth test on to prove stability.
  4. Texture mapping: with barycentrics in place, add perspective-correct interpolation (uOverW, vOverW, invW → divide to sample). Start nearest, then add
     clamp/wrap. Feed in a simple checker to verify.
  5. Cubes/meshes: define indexed vertices with positions, colors/uvs, iterate faces, apply transforms, submit to rasterizer. With depth + textures
     working, cubes fall out easily.

