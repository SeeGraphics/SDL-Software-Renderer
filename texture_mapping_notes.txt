Texture mapping overview
------------------------

- What was added
  - A `Texture` struct (width, height, pixels) and `VertexUV` (screen pos + uv) live in `src/types.h`.
  - Loader helpers in `src/render.c`: `texture_load` (loads a PNG with SDL_image, converts to ARGB8888, copies pixels) and `texture_destroy`.
  - Normalized/screen helpers already present; a new textured rasterizer `draw_textured_triangle` in `src/shapes.c` does barycentric interpolation of UVs and samples the texture.
  - Main loop (`src/main.c`) now:
    - Initializes SDL_image, loads `assets/texture.png` (adjust the path as needed).
    - Keeps triangle vertices in normalized space, converts to screen each frame, and feeds UVs into the textured draw.
    - Still supports dragging vertices; dragged screen positions are written back to normalized coords so resize stays correct.
  - Makefile links SDL2_image and pulls SDL include flags via `sdl2-config`/pkg-config.

- How the textured raster works
  - Computes the triangleâ€™s bounding box in screen space, clamps to the framebuffer.
  - Uses an edge function to get barycentric weights (`w0, w1, w2`) at each pixel center `(x+0.5, y+0.5)`.
  - Rejects pixels outside the triangle (`wN < 0`), otherwise interpolates `u,v` = `w0*u0 + w1*u1 + w2*u2`.
  - Clamps `u,v` to [0,1], maps to integer texel coordinates, samples ARGB8888, and writes to the framebuffer.

- How to modify/extend
  - Change the texture: update `texture_path` in `src/main.c` to your PNG; keep UVs in [0,1]. Flipping V can be done by swapping `uv.y -> 1.0f - uv.y`.
  - Add color interpolation: extend `VertexUV` to carry a color and lerp it alongside UVs (modulate sampled texels).
  - Perspective correctness: when you add 3D, store per-vertex `uOverW`, `vOverW`, and `invW`; interpolate those and divide (`u = uOverW / invW`, same for `v`) before sampling.
  - Wrapping modes: replace the clamp on `u,v` with wrap (`fmodf(u,1.0f)`) or mirror, and guard negatives.
  - Filtering: replace nearest sample with bilinear by sampling the four neighboring texels and blending by the fractional part of `u,v`.
  - Depth: add a depth buffer, interpolate depth (or `1/w`) with the barycentric weights, and skip pixels behind the stored depth.
